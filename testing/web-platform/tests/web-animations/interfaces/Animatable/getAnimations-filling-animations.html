<!doctype html>
<meta charset=utf-8>
<title>Animatable.getAnimations (forwards-filling animation handling)</title>
<link rel="help" href="https://drafts.csswg.org/web-animations/#dom-animatable-getanimations">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../../testcommon.js"></script>
<body>
<script>
'use strict';

test(t => {
  const div = createDiv(t);
  const animation = div.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  animation.finish();
  assert_class_string(div.getAnimations()[0], 'FillAnimation');
}, 'Returns a FillAnimation for animations that fill forwards');

test(t => {
  const div = createDiv(t);
  const animation = div.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  animation.finish();

  // Originally we should get a FillAnimation
  assert_equals(div.getAnimations().length, 1);
  assert_not_equals(div.getAnimations()[0], animation);

  animation.currentTime = 50 * MS_PER_SEC;

  // But after seeking we should get |animation|
  assert_equals(div.getAnimations().length, 1);
  assert_equals(div.getAnimations()[0], animation);
}, 'Returns the original Animation if it is seeked back to the running state');

test(t => {
  const div = createDiv(t);
  const animation = div.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  animation.finish();
  const fillAnimation = div.getAnimations()[0];

  animation.cancel();

  assert_equals(div.getAnimations().length, 0);
  assert_equals(fillAnimation.playState, 'idle');
}, 'Does not return a FillAnimation if the corresponding Animation is'
   + ' canceled');

test(t => {
  const div = createDiv(t);
  const animation = div.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  animation.finish();
  const fillAnimation = div.getAnimations()[0];

  animation.effect.target = null;

  assert_equals(div.getAnimations().length, 0);
}, 'Does not return a FillAnimation if the target element of the corresponding'
   + ' Animation is set to null');

test(t => {
  const div = createDiv(t);
  const animation = div.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  animation.finish();
  const fillAnimation = div.getAnimations()[0];

  animation.effect = null;

  assert_equals(div.getAnimations().length, 0);
}, 'Does not return a FillAnimation if the effect of the corresponding'
   + ' Animation is set to null');

test(t => {
  const div = createDiv(t);
  const animation = div.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  animation.finish();
  const fillAnimation = div.getAnimations()[0];

  // This will make the animation idle
  animation.timeline = null;

  assert_equals(div.getAnimations().length, 0);
}, 'Does not return a FillAnimation if the timeline of the corresponding'
   + ' Animation is set to null');

test(t => {
  const div = createDiv(t);
  const effect = new KeyframeEffect(div, null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  const animation = new Animation(effect, null);
  animation.startTime = document.timeline.currentTime - 100 * MS_PER_SEC;

  // Initially the Animation won't be returned by getAnimations() because it is
  // 'idle' (no current time).
  assert_equals(div.getAnimations().length, 0);

  // After assigning the timeline it should become 'finished' and represented by
  // a FillAnimation.
  animation.timeline = document.timeline;

  assert_class_string(div.getAnimations()[0], 'FillAnimation');
}, 'Returns a FillAnimation if a forwards-filling Animation is assigned a'
   + ' monotonically-increasing timeline');

test(t => {
  const div = createDiv(t);
  const animA = div.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  const animB = div.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  const animC = div.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  for (const anim of [animA, animB, animC]) {
    anim.finish();
  }

  assert_equals(div.getAnimations().length, 1);
}, 'Returns a single FillAnimation to represent multiple adjacent filling'
   + ' animations');

test(t => {
  const div = createDiv(t);

  const forwards = div.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  forwards.finish();

  const backwards = div.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'backwards',
  });
  backwards.playbackRate = -1;
  backwards.finish();

  assert_equals(div.getAnimations().length, 1);
}, 'Returns a single FillAnimation to represent multiple adjacent filling'
   + ' animations even if they fill in different directions');

test(t => {
  const div = createDiv(t);
  const animA = div.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  const animB = div.animate(null, {
    duration: 100 * MS_PER_SEC,
    // Notice no fill mode here
  });
  const animC = div.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  for (const anim of [animA, animB, animC]) {
    anim.finish();
  }

  assert_equals(div.getAnimations().length, 1);
}, 'Returns a single FillAnimation to represent multiple adjacent filling'
   + ' animations even if they were not previously adjacent');

test(t => {
  const div = createDiv(t);
  const animA = div.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  const animB = div.animate(null, {
    duration: 200 * MS_PER_SEC,
  });
  const animC = div.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });

  animA.finish();
  // Don't finish animB
  animC.finish();

  assert_equals(div.getAnimations().length, 3);
}, 'Returns separate FillAnimation objects if the filling animations are not'
   + ' adjacent');

test(t => {
  const div = createDiv(t);

  const animA = div.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  animA.finish();

  const animB = div.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  animB.timeline = new DocumentTimeline();
  animB.finish();

  assert_equals(div.getAnimations().length, 2);
}, 'Returns separate FillAnimation objects if adjacent filling animations have'
   + ' different timelines');

test(t => {
  const div1 = createDiv(t);
  const div2 = createDiv(t);

  const animA = div1.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  const animB = div2.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  const animC = div1.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });

  animA.finish();
  animC.finish();

  // Initially we should have: [FillAnimationAC]
  assert_equals(div1.getAnimations().length, 1);

  // If we re-target animB at div1, however, we will need to split the
  // FillAnimation so we get [FillAnimationA, animB, FillAnimationC].
  animB.effect.target = div1;
  assert_equals(div1.getAnimations().length, 3);
}, 'Splits a combined FillAnimation if an interleaving animation appears');

test(t => {
  const div = createDiv(t);
  const animA = div.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  const animB = div.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  animA.finish();
  animB.finish();

  assert_equals(div.getAnimations().length, 1);
  const fillAnimAB = div.getAnimations()[0];
  assert_equals(fillAnimAB, div.getAnimations()[0],
                'The same FillAnimation object should be returned each time');

  const animC = div.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  animC.finish();

  assert_equals(div.getAnimations().length, 1);
  const fillAnimABC = div.getAnimations()[0];
  assert_not_equals(fillAnimABC, fillAnimAB,
                    'A new FillAnimation object should be returned when the set'
                    + ' of underlying animations changes (by adding)');

  animC.cancel();
  assert_equals(fillAnimAB, div.getAnimations()[0],
                'After canceling the additional animation, the previously'
                + ' returned animation should be returned');

  animA.cancel();
  assert_not_equals(fillAnimAB, div.getAnimations()[0],
                    'After canceling one of the original animations, a new'
                    + ' FillAnimation object should be returned');
}, 'Returns the same FillAnimation for the same set of underlying animations');

test(t => {
  const divA = createDiv(t);
  const divB = createDiv(t);
  const animation = divA.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  animation.finish();

  const fillAnimationA = divA.getAnimations()[0];

  animation.effect.target = divB;

  // FillAnimation on original div should be canceled
  assert_equals(divA.getAnimations().length, 0);
  assert_equals(fillAnimationA.playState, 'idle');

  // A new FillAnimation should be generated on the new target div
  assert_equals(divB.getAnimations().length, 1);
  const fillAnimationB = divB.getAnimations()[0];
  assert_not_equals(fillAnimationA, fillAnimationB);
  assert_class_string(fillAnimationB, 'FillAnimation');
}, 'Returns a new FillAnimation if the target element of the corresponding'
   + ' Animation is set to a different element');

test(t => {
  const divA = createDiv(t);
  const animation = divA.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  animation.finish();
  const fillAnimationA = divA.getAnimations()[0];

  const divB = createDiv(t);
  const effectB = new KeyframeEffect(divB, null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  animation.effect = effectB;

  // FillAnimation on original div should be canceled
  assert_equals(divA.getAnimations().length, 0);
  assert_equals(fillAnimationA.playState, 'idle');

  // A new FillAnimation should be generated on the new target div
  assert_equals(divB.getAnimations().length, 1);
  const fillAnimationB = divB.getAnimations()[0];
  assert_not_equals(fillAnimationA, fillAnimationB);
  assert_class_string(fillAnimationB, 'FillAnimation');
  assert_equals(fillAnimationB.playState, 'running');
}, 'Returns a new FillAnimation if the effect of the corresponding Animation'
   + ' is updated to an effect with a different target element');

test(t => {
  const div = createDiv(t);
  const animation = div.animate(null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  animation.finish();
  const fillAnimationA = div.getAnimations()[0];

  const effectB = new KeyframeEffect(div, null, {
    duration: 100 * MS_PER_SEC,
    fill: 'forwards',
  });
  animation.effect = effectB;

  // A new FillAnimation should be generated due to the change in effect
  // identity.
  assert_equals(div.getAnimations().length, 1);
  const fillAnimationB = div.getAnimations()[0];
  assert_not_equals(fillAnimationA, fillAnimationB);
  assert_class_string(fillAnimationB, 'FillAnimation');
  assert_equals(fillAnimationB.playState, 'running');

  // The original FillAnimation should be canceled
  assert_equals(fillAnimationA.playState, 'idle');
}, 'Returns a new FillAnimation if the effect of the corresponding'
   + ' Animation is updated to an effect with the same target element');

</script>
</body>
